import * as fs from 'fs';
import {
    webpack,
    Compiler,
} from 'webpack';
import { Logger } from '@agros/logger';
import WebpackDevServer from 'webpack-dev-server';
import { checkBrowsers } from 'react-dev-utils/browsersHelper';
import checkRequiredFiles from 'react-dev-utils/checkRequiredFiles';
import {
    choosePort,
    createCompiler,
    prepareProxy,
    prepareUrls,
} from 'react-dev-utils/WebpackDevServerUtils';
import paths from '../builder/paths';
// Ensure environment variables are read.
import '../builder/env';
import {
    generateBuildConfig,
    generateDevServerConfig,
} from '../builder/generators';

// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = 'development';
process.env.NODE_ENV = 'development';

export default () => {
    // Makes the script crash on unhandled rejections instead of silently
    // ignoring them. In the future, promise rejections that are not handled will
    // terminate the Node.js process with a non-zero exit code.
    process.on('unhandledRejection', (err) => {
        throw err;
    });

    const useYarn = fs.existsSync(paths.yarnLockFile);
    const isInteractive = process.stdout.isTTY;

    // Warn and crash if required files are missing
    if (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) {
        process.exit(1);
    }

    // Tools like Cloud9 rely on this.
    const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
    const HOST = process.env.HOST || '0.0.0.0';

    const logger = new Logger();

    if (process.env.HOST) {
        logger.warning(`Attempting to bind to HOST environment variable: ${process.env.HOST}`);
        logger.info('If this was unintentional, check that you haven\'t mistakenly set it in your shell.');
        logger.info('\n');
    }

    // We require that you explicitly set browsers and do not fall back to
    // browserslist defaults.
    checkBrowsers(paths.appPath, isInteractive)
        .then(() => {
        // We attempt to use the default port but if it is busy, we offer the user to
        // run on a different port. `choosePort()` Promise resolves to the next free port.
            return choosePort(HOST, DEFAULT_PORT);
        })
        .then((port) => {
            if (port === null) {
                // We have not found a port.
                return;
            }

            const config = generateBuildConfig('development');
            const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
            const appName = require(paths.appPackageJson).name;

            const useTypeScript = fs.existsSync(paths.appTsConfig);
            const urls = (prepareUrls as any)(
                protocol,
                HOST,
                port,
                paths.publicUrlOrPath.slice(0, -1),
            );
            // Create a webpack compiler that is configured with custom messages.
            const compiler: Compiler = createCompiler({
                appName,
                config,
                urls,
                useYarn,
                useTypeScript,
                webpack,
            } as any) as unknown as Compiler;
            // Load proxy config
            const proxySetting = require(paths.appPackageJson).proxy;
            const proxyConfig = prepareProxy(
                proxySetting,
                paths.appPublic,
                paths.publicUrlOrPath,
            );
            // Serve webpack assets generated by the compiler over a web server.
            const serverConfig = {
                ...generateDevServerConfig(proxyConfig, urls.lanUrlForConfig),
                host: HOST,
                port,
            };
            const devServer = new WebpackDevServer(serverConfig as any, compiler);
            // Launch WebpackDevServer.
            devServer.startCallback(() => {
                logger.info('Starting the development server...\n');
            });

            ['SIGINT', 'SIGTERM'].forEach((sig) => {
                process.on(sig, () => {
                    devServer.close();
                    process.exit();
                });
            });

            if (process.env.CI !== 'true') {
                // Gracefully exit when stdin ends
                process.stdin.on('end', () => {
                    devServer.close();
                    process.exit();
                });
            }
        })
        .catch((e) => {
            if (e?.message) {
                console.log(e.message);
            }
            process.exit(1);
        });
};
